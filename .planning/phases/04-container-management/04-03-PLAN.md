---
phase: 04-container-management
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/dashboard/src/app/(dashboard)/page.tsx
  - apps/dashboard/src/app/(dashboard)/containers/page.tsx
  - apps/dashboard/src/components/containers/summary-bar.tsx
  - apps/dashboard/src/components/containers/container-card.tsx
  - apps/dashboard/src/components/containers/container-grid.tsx
  - apps/dashboard/src/components/containers/status-badge.tsx
  - apps/dashboard/src/components/containers/container-actions.tsx
  - apps/dashboard/src/hooks/use-auto-refresh.ts
  - apps/dashboard/src/lib/containers/data.ts
autonomous: true

must_haves:
  truths:
    - "User can see the total, running, stopped, and error container counts on the dashboard"
    - "User can see container cards in a responsive grid showing hostname, VMID, status, service dots, and resource summary"
    - "Container cards show first 2-3 service names with colored dots (green/gray/red) and +N more link to detail"
    - "Container cards show text resource summary line (CPU X% · Mem X/X MB) — no progress bars"
    - "Container status reflects the live Proxmox status (running/stopped), not just the DB lifecycle"
    - "User can filter containers by status (all, running, stopped, error)"
    - "User can trigger start/stop/restart/delete from a dropdown menu (three-dot button) on each card"
    - "Destructive actions (stop, delete) use shadcn AlertDialog showing container hostname and VMID"
    - "Toast notification appears after every lifecycle action (success or error)"
    - "Dashboard auto-refreshes every 30 seconds with live countdown timer and Refresh Now button"
    - "Auto-refresh pauses when tab is hidden, immediate refresh on tab focus"
    - "Warning banner appears when Proxmox API is unreachable"
    - "Empty state shows a link to the container creation wizard"
  artifacts:
    - path: "apps/dashboard/src/app/(dashboard)/page.tsx"
      provides: "Dashboard page with server-side data fetching and Proxmox status sync"
      contains: "SummaryBar"
    - path: "apps/dashboard/src/components/containers/container-card.tsx"
      provides: "Container card component with status badge, info, and action buttons"
      contains: "ContainerCard"
    - path: "apps/dashboard/src/lib/containers/data.ts"
      provides: "getContainersWithStatus and getContainerDetailData functions that merge DB + Proxmox status"
      contains: "getContainersWithStatus"
  key_links:
    - from: "apps/dashboard/src/app/(dashboard)/page.tsx"
      to: "apps/dashboard/src/lib/containers/data.ts"
      via: "Server component calls getContainersWithStatus for merged data"
      pattern: "getContainersWithStatus"
    - from: "apps/dashboard/src/components/containers/container-actions.tsx"
      to: "apps/dashboard/src/lib/containers/actions.ts"
      via: "Quick actions call lifecycle server actions"
      pattern: "startContainerAction|stopContainerAction|deleteContainerAction"
    - from: "apps/dashboard/src/app/(dashboard)/page.tsx"
      to: "apps/dashboard/src/lib/db.ts"
      via: "Fetches container counts via DatabaseService"
      pattern: "getContainerCounts"
---

<objective>
Build the container dashboard page — the main landing page showing a summary bar with counts, a responsive grid of container cards with live Proxmox status, filter controls, quick lifecycle actions, auto-refresh, and an empty state linking to the creation wizard.

Purpose: This is the primary interface users see. It gives an at-a-glance view of all containers and their health, with quick controls for common lifecycle actions.

Output: Replaced placeholder dashboard with full container management overview.
</objective>

<execution_context>
@/home/coder/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-container-management/04-01-SUMMARY.md

@apps/dashboard/src/app/(dashboard)/page.tsx
@apps/dashboard/src/app/(dashboard)/layout.tsx
@apps/dashboard/src/lib/db.ts
@apps/dashboard/src/lib/containers/helpers.ts
@apps/dashboard/src/lib/containers/actions.ts
@apps/dashboard/src/lib/proxmox/containers.ts
@apps/dashboard/src/lib/proxmox/schemas.ts
@apps/dashboard/src/components/ui/card.tsx
@apps/dashboard/src/components/ui/button.tsx
@apps/dashboard/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Container data fetching with Proxmox status sync</name>
  <files>
    apps/dashboard/src/lib/containers/data.ts
  </files>
  <action>
Create `src/lib/containers/data.ts` with `import "server-only"`. This provides data fetching functions that merge DB records with live Proxmox status.

**Types:**

```ts
export type ContainerStatus =
  | "running"
  | "stopped"
  | "creating"
  | "error"
  | "unknown";

export interface ContainerWithStatus {
  id: string;
  vmid: number;
  hostname: string | null; // From Proxmox, may be null
  status: ContainerStatus;
  lifecycle: "creating" | "ready" | "error";
  ip: string | null;
  uptime: number | null; // seconds
  memory: { used: number; max: number } | null;
  cpu: number | null; // 0-1 fraction
  disk: { used: number; max: number } | null;
  template: { id: string; name: string } | null;
  node: { id: string; name: string };
  serviceCount: number;
  servicesHealthy: number; // count of services with status "running"
  services: Array<{ name: string; status: string }>; // first 3 services for card dots display
  createdAt: Date;
}

export interface DashboardData {
  containers: ContainerWithStatus[];
  counts: {
    total: number;
    running: number;
    stopped: number;
    creating: number;
    error: number;
  };
  proxmoxReachable: boolean; // false when Proxmox API call failed
}
```

**Main function:**

```ts
export async function getContainersWithStatus(): Promise<DashboardData>;
```

Implementation:

1. Call `createProxmoxClientFromSession()` from helpers to get client + node
2. Call `DatabaseService.listContainersWithRelations()` to get all DB containers
3. Call `listContainers(client, node.name)` from Proxmox to get live status for ALL containers on the node (single API call, efficient)
4. Merge: For each DB container:
   - Find matching Proxmox container by VMID
   - If found and lifecycle is "ready": use Proxmox status (running/stopped)
   - If lifecycle is "creating": status = "creating"
   - If lifecycle is "error": status = "error"
   - If not found in Proxmox: status = "unknown" (container may have been deleted externally)
   - Extract hostname, IP (from Proxmox name field), memory, CPU, disk from Proxmox data
   - Count services and healthy services from DB relations
5. Calculate counts from merged data
6. Return `{ containers, counts }`

For IP extraction: Proxmox's listContainers response doesn't include IP directly. The container's `name` field is the hostname. For IP, we'd need to query each container's config (expensive for many containers). **Compromise:** Don't show IP on dashboard cards (show it on detail page only where we query config for a single container). Show hostname (from Proxmox `name` field) instead.

Handle Proxmox API failures gracefully: if the API call fails (e.g., expired session), still return DB data with status "unknown" for all containers. Log the error but don't crash the page.

**Also add `getContainerDetailData` in the same file** (used by Plan 04-04's detail page):

Types:

```ts
export type ContainerStatus =
  | "running"
  | "stopped"
  | "creating"
  | "error"
  | "unknown";

export interface ContainerDetailData {
  id: string;
  vmid: number;
  hostname: string | null;
  status: ContainerStatus;
  lifecycle: "creating" | "ready" | "error";
  createdAt: Date;
  updatedAt: Date;
  config: {
    cores: number | null;
    memory: number | null;
    swap: number | null;
    disk: string | null;
    hostname: string | null;
    nameserver: string | null;
    searchdomain: string | null;
    net0: string | null;
    features: string | null;
    unprivileged: boolean | null;
    ostype: string | null;
    arch: string | null;
    description: string | null;
    tags: string | null;
    onboot: boolean | null;
  };
  resources: {
    cpuUsage: number | null;
    memUsed: number | null;
    memMax: number | null;
    swapUsed: number | null;
    swapMax: number | null;
    diskUsed: number | null;
    diskMax: number | null;
    uptime: number | null;
    netIn: number | null;
    netOut: number | null;
  };
  template: { id: string; name: string; description: string | null } | null;
  node: { id: string; name: string; host: string };
  services: Array<{
    id: string;
    name: string;
    type: string;
    port: number | null;
    webUrl: string | null;
    status: string;
    credentials: string | null;
  }>;
  events: Array<{
    id: string;
    type: string;
    message: string;
    metadata: string | null;
    createdAt: Date;
  }>;
}
```

Function:

```ts
export async function getContainerDetailData(
  containerId: string,
): Promise<ContainerDetailData | null>;
```

Implementation:

1. Call `DatabaseService.getContainerWithDetails(containerId)` — return null if not found
2. Call `createProxmoxClientFromSession()` to get client + node
3. Call `getContainer(client, node.name, container.vmid)` for live status + resources
4. Call `getContainerConfig(client, node.name, container.vmid)` for full config
5. Merge: DB data + Proxmox status + Proxmox config → ContainerDetailData
6. If Proxmox API calls fail, still return data with null resources and config from DB only

Handle the case where container doesn't exist in Proxmox (deleted externally): return data with status "unknown" and null resources.

  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - File exists at `apps/dashboard/src/lib/containers/data.ts`
    - Exports `getContainersWithStatus`, `ContainerWithStatus`, `DashboardData`, `getContainerDetailData`, `ContainerDetailData`
    - Both functions handle Proxmox API failure gracefully (returns "unknown" status)
    - Functions merge DB lifecycle with live Proxmox status correctly
  </verify>
  <done>
    - getContainersWithStatus merges DB + Proxmox data in a single efficient call for dashboard
    - getContainerDetailData merges DB + Proxmox config + Proxmox status for detail page
    - ContainerWithStatus type provides all data needed for container cards
    - ContainerDetailData type provides all data needed for detail page tabs
    - Proxmox API failure doesn't crash the page
    - Status correctly derived: creating containers show "creating", ready containers show Proxmox live status
  </done>
</task>

<task type="auto">
  <name>Task 2: Atomic UI components (status-badge, container-actions, container-card)</name>
  <files>
    apps/dashboard/src/components/containers/status-badge.tsx
    apps/dashboard/src/components/containers/container-actions.tsx
    apps/dashboard/src/components/containers/container-card.tsx
  </files>
  <action>
**1. Create `src/components/containers/status-badge.tsx`** (client component)

A small badge component showing container status with appropriate colors:

- `running` → green (bg-green-100 text-green-700)
- `stopped` → gray (bg-gray-100 text-gray-700)
- `creating` → blue (bg-blue-100 text-blue-700) with pulse animation
- `error` → red (bg-red-100 text-red-700)
- `unknown` → yellow (bg-yellow-100 text-yellow-700)

Use shadcn Badge if available, otherwise a simple `<span>` with rounded-full, px-2, py-0.5, text-xs, font-medium classes. Export `StatusBadge` taking `{ status: ContainerStatus }`.

**2. Create `src/components/containers/container-actions.tsx`** (client component — `"use client"`)

Quick action dropdown for a container card. Uses `useTransition` for loading spinner state only (NOT for optimistic status updates — status changes only via `revalidatePath` after the action completes on the server, per user decision).

Props: `{ containerId: string; status: ContainerStatus; containerName: string | null; vmid: number }`

**Layout: shadcn DropdownMenu with three-dot/ellipsis trigger** (per locked decision — card actions must use dropdown to keep cards compact):

- Trigger: `<Button variant="ghost" size="icon">` with `<MoreHorizontal />` Lucide icon
- DropdownMenu items based on status:
  - Running: "Start" (disabled), "Stop", "Restart", "Delete"
  - Stopped: "Start", "Stop" (disabled), "Restart" (disabled), "Delete"
  - Creating/Error/Unknown: "Delete" only

Each DropdownMenuItem:

- Uses `useTransition` to track pending state (show `<Loader2 className="animate-spin" />` while pending)
- Calls the corresponding server action via `useAction` from `next-safe-action/hooks` (matching authActionClient pattern)
- **Destructive actions (stop, delete) open a shadcn AlertDialog** — NOT browser `confirm()` (per locked decision)
  - AlertDialog clearly names the container: "Are you sure you want to stop **{containerName}** (VMID {vmid})?"
  - For delete: "Are you sure you want to delete **{containerName}** (VMID {vmid})? This action cannot be undone."
  - Use `<AlertDialogAction>` with destructive variant for confirm button
- **Toast notification after every action** (per locked decision): use `sonner` toast (already available via shadcn)
  - On success: `toast.success("Container started successfully")`
  - On error: `toast.error(result.serverError || "Failed to start container")`

Install lucide-react if not already available: `pnpm add lucide-react` (check package.json first).
Install shadcn AlertDialog if not present: `npx shadcn@latest add alert-dialog`.
Install shadcn DropdownMenu if not present: `npx shadcn@latest add dropdown-menu`.
Ensure sonner/toast is available: `npx shadcn@latest add sonner` (check if `<Toaster />` is already in layout).

**3. Create `src/components/containers/container-card.tsx`** (client component for actions)

A Card showing container info with fixed height (per locked decision — responsive grid with fixed card height):

- **Header:** Hostname (bold, most prominent) + StatusBadge. VMID shown as muted small text below hostname.
- **Body:**
  - Template name (muted, if any)
  - **Service names with colored status dots** (per locked decision): Show first 2-3 service names inline, each with a colored dot (green for running, gray for stopped, red for error). If more services exist, show "+N more" as a link to `/containers/{id}?tab=services` (navigates to detail page Services tab).
  - **Text-only resource summary line** (per locked decision): "CPU 23% · Mem 256/512 MB" — NO progress bars on cards. Format CPU as percentage (multiply the 0-1 fraction by 100), memory as used/max in MB. If resources are null (container stopped or unknown), show "—" or omit the line.
- **Footer:** DropdownMenu trigger (three-dot button via ContainerActions) positioned in top-right corner of card
- **Click:** Entire card (except action buttons) links to `/containers/{id}` using Next.js Link

Use shadcn Card with CardHeader, CardContent, CardFooter.

Props: `ContainerWithStatus` (from data.ts types — must include `services` array with name/status for dots, or `serviceNames` and `servicesHealthy`/`serviceCount` fields).

**Note:** The `ContainerWithStatus` type from Task 1 needs to include service detail for the card dots. Add a `services: Array<{ name: string; status: string }>` field (first 3 services) to ContainerWithStatus, populated from the DB relation in `getContainersWithStatus()`.

For relative time: use a simple helper function `timeAgo(date: Date): string` — no external dependency. Handle: "just now", "X minutes ago", "X hours ago", "X days ago".

  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - StatusBadge renders correct colors per status
    - ContainerActions uses shadcn DropdownMenu with three-dot trigger (not inline icon buttons)
    - ContainerActions uses shadcn AlertDialog for destructive actions (not browser confirm())
    - ContainerActions shows toast notification (via sonner) after every lifecycle action (success and error)
    - ContainerActions uses useTransition for loading spinner only (no optimistic status updates)
    - ContainerCard shows hostname (prominent), VMID (muted), status badge, template
    - ContainerCard shows first 2-3 service names with colored dots (green/gray/red) and "+N more" link
    - ContainerCard shows text resource summary line "CPU X% · Mem X/X MB" (no progress bars)
    - All components use shadcn/ui Card, DropdownMenu, AlertDialog, and Tailwind classes
  </verify>
  <done>
    - StatusBadge component with color-coded status indicators
    - ContainerActions: dropdown menu (three-dot), AlertDialog for destructive actions, toast after every action, loading spinner via useTransition (no optimistic status)
    - ContainerCard: hostname + status prominent, service dots with colored indicators, text resource summary, "+N more" linking to detail Services tab
  </done>
</task>

<task type="auto">
  <name>Task 3: Composition components and dashboard page (summary-bar, container-grid, page.tsx)</name>
  <files>
    apps/dashboard/src/components/containers/summary-bar.tsx
    apps/dashboard/src/components/containers/container-grid.tsx
    apps/dashboard/src/app/(dashboard)/page.tsx
    apps/dashboard/src/app/(dashboard)/containers/page.tsx
  </files>
  <action>
**1. Create `src/components/containers/summary-bar.tsx`** (server component)

A row of 4 stat cards:

- Total containers (count)
- Running (count, green accent)
- Stopped (count, gray accent)
- Error (count, red accent — only show if > 0)

Use shadcn Card, small size. Responsive: 4 cols on lg, 2 cols on md, 1 col on mobile.

Props: `{ counts: DashboardData["counts"] }`

**2. Create `src/components/containers/container-grid.tsx`** (client component — `"use client"`)

Container grid with filter controls and auto-refresh.

Props: `{ containers: ContainerWithStatus[] }`

Features:

- **Filter bar:** Buttons for "All", "Running", "Stopped", "Error" — uses `useState` for active filter
- **Sort:** By name (default), by status, by date — use `useState` for sort
- **Grid:** Responsive grid of ContainerCards (3 cols on lg, 2 on md, 1 on mobile) with fixed card height
- **Empty state:** If no containers at all, show a Card with message "No containers yet" and a Button linking to `/containers/new` ("Create your first container")
- **Filtered empty state:** If filter yields no results, show "No {status} containers"
- **Auto-refresh with countdown timer** (per locked decision — ALL of these are required):
  - Use `useRouter().refresh()` every 30 seconds via `useEffect` + `setInterval`. This triggers server component re-render, which re-fetches data. Clean up interval on unmount.
  - **Live countdown timer:** Small muted text near the grid header (unobtrusive per user suggestion) showing "Refreshing in Xs" counting down from 30. Use a separate `useState<number>(30)` decremented every 1s.
  - **"Refresh Now" button:** Small outline button next to the countdown timer. On click, calls `router.refresh()` immediately and resets the countdown to 30.
  - **visibilitychange handling:** Add `document.addEventListener("visibilitychange", ...)` in useEffect. When tab becomes hidden (`document.hidden === true`), pause the countdown interval. When tab becomes visible again, trigger an immediate refresh (`router.refresh()`) and restart the 30s countdown. Clean up listener on unmount.
  - **Consider extracting a `useAutoRefresh(intervalMs)` custom hook** that encapsulates the countdown, Refresh Now, and visibilitychange logic. This hook will be reused by the detail page (Plan 04-04). Return `{ secondsUntilRefresh, refreshNow, isRefreshing }`.

Props should also accept `proxmoxReachable: boolean` (passed from server component):

- **Proxmox-unreachable warning banner** (per locked decision): If `proxmoxReachable === false`, show a subtle warning banner above the grid: "Could not reach Proxmox — showing last known status" with a "Retry" button that calls `router.refresh()`. Use shadcn `Alert` with `variant="default"` and a muted/warning style (yellow-ish background or border).

Update `getContainersWithStatus()` in data.ts to also return a `proxmoxReachable: boolean` field in `DashboardData` — set to `false` when the Proxmox API call fails (already handled gracefully), `true` otherwise.

**3. Replace `src/app/(dashboard)/page.tsx`** (server component)

Replace the placeholder dashboard with:

```tsx
import { getContainersWithStatus } from "@/lib/containers/data";
import { SummaryBar } from "@/components/containers/summary-bar";
import { ContainerGrid } from "@/components/containers/container-grid";

export default async function DashboardPage() {
  const { containers, counts, proxmoxReachable } =
    await getContainersWithStatus();

  return (
    <div className="flex flex-1 flex-col gap-6">
      <div>
        <h1 className="text-3xl font-bold">Dashboard</h1>
        <p className="text-muted-foreground">
          Monitor and manage your LXC containers
        </p>
      </div>

      <SummaryBar counts={counts} />
      <ContainerGrid
        containers={containers}
        proxmoxReachable={proxmoxReachable}
      />
    </div>
  );
}
```

**4. Create `src/app/(dashboard)/containers/page.tsx`** that redirects to `/` or shows the same dashboard (both routes should work). Simplest: make it import and re-export the same page, or use `redirect("/")` from `next/navigation`.

  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Dashboard page at `src/app/(dashboard)/page.tsx` imports and renders SummaryBar + ContainerGrid
    - SummaryBar shows 4 count cards
    - ContainerGrid has filter buttons, 30s auto-refresh with live countdown timer, and "Refresh Now" button
    - ContainerGrid pauses auto-refresh when tab is hidden (visibilitychange), immediate refresh on tab focus
    - Proxmox-unreachable warning banner shows when proxmoxReachable is false
    - Empty state shows link to /containers/new
    - `/containers` route works (redirect or same content)
    - useAutoRefresh hook extracted for reuse by detail page
  </verify>
  <done>
    - Summary bar shows total/running/stopped/error counts
    - Container grid with filter by status, 30s auto-refresh, countdown timer, Refresh Now button
    - Auto-refresh pauses on hidden tab, immediate refresh on focus return (visibilitychange)
    - Proxmox-unreachable warning banner with Retry button
    - useAutoRefresh hook reusable for detail page
    - Dashboard page wired: server component fetches data, passes to client components
    - Empty state guides user to create first container
    - /containers route redirects to dashboard
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — all files type-check
2. Dashboard page renders SummaryBar and ContainerGrid
3. Status correctly synced from Proxmox API (running containers show green)
4. Card actions use shadcn DropdownMenu with three-dot trigger (not inline icon buttons)
5. Destructive actions use shadcn AlertDialog showing container hostname and VMID (not browser confirm())
6. Toast notification shows after every lifecycle action (success and error)
7. Container cards show service names with colored dots (green/gray/red) and "+N more" link
8. Container cards show text resource summary "CPU X% · Mem X/X MB" (no progress bars)
9. Auto-refresh works (30s interval) with live countdown timer and "Refresh Now" button
10. Auto-refresh pauses on hidden tab, immediate refresh on tab focus (visibilitychange)
11. Proxmox-unreachable warning banner appears when API call fails
12. Filter buttons work for All/Running/Stopped/Error
13. Empty state renders with link to wizard
14. Proxmox API failure shows containers with "unknown" status (doesn't crash)
</verification>

<success_criteria>

- Dashboard shows real container data from DB + Proxmox
- Status badges reflect live Proxmox status
- Card actions via dropdown menu (three-dot), AlertDialog for destructive actions, toasts for all actions
- Container cards show service dots with colors, resource summary text line
- Auto-refresh with countdown timer, Refresh Now, visibilitychange pause/resume
- Proxmox-unreachable warning banner with Retry
- Empty state guides new users to create containers
- Responsive layout works on desktop and mobile
  </success_criteria>

<output>
After completion, create `.planning/phases/04-container-management/04-03-SUMMARY.md`
</output>
