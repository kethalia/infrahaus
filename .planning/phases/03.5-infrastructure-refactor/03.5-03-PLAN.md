---
phase: 03.5-infrastructure-refactor
plan: 03
type: execute
wave: 2
depends_on: ["03.5-01"]
files_modified:
  - apps/dashboard/src/lib/vmid-cache.ts
  - apps/dashboard/src/lib/nodes/schemas.ts
  - apps/dashboard/src/lib/nodes/actions.ts
  - apps/dashboard/src/lib/constants/infrastructure.ts
autonomous: true

must_haves:
  truths:
    - "VMID cache can be refreshed from Proxmox and queried for taken VMIDs"
    - "Node CRUD actions exist with connection testing on create/update"
    - "First node added for a user becomes the default automatically"
    - "Node actions validate input with Zod schemas"
  artifacts:
    - path: "apps/dashboard/src/lib/vmid-cache.ts"
      provides: "Redis VMID cache with refresh, check, and invalidation"
      contains: "refreshVmidCache"
    - path: "apps/dashboard/src/lib/nodes/schemas.ts"
      provides: "Zod schemas for node forms"
      contains: "createNodeSchema"
    - path: "apps/dashboard/src/lib/nodes/actions.ts"
      provides: "Server actions for node CRUD"
      contains: "createNodeAction"
  key_links:
    - from: "apps/dashboard/src/lib/vmid-cache.ts"
      to: "apps/dashboard/src/lib/redis.ts"
      via: "getRedis() for cache operations"
      pattern: "getRedis"
    - from: "apps/dashboard/src/lib/nodes/actions.ts"
      to: "apps/dashboard/src/lib/proxmox/client.ts"
      via: "ProxmoxClient for connection testing"
      pattern: "new ProxmoxClient"
---

<objective>
Create the VMID cache module and node management server actions. These are new modules that don't modify existing call sites — they provide the building blocks for the settings page and wizard updates.

Purpose: Node CRUD actions are needed by the settings page (Plan 06). VMID cache is needed by the wizard (Plan 07). Building these now as independent modules enables parallel work later.
Output: vmid-cache.ts module, nodes/schemas.ts, nodes/actions.ts with full CRUD + connection testing.
</objective>

<execution_context>
@/home/coder/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03.5-infrastructure-refactor/03.5-RESEARCH.md
@apps/dashboard/src/lib/redis.ts
@apps/dashboard/src/lib/proxmox/client.ts
@apps/dashboard/src/lib/encryption.ts
@apps/dashboard/src/lib/safe-action.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Redis VMID cache module</name>
  <files>
    apps/dashboard/src/lib/vmid-cache.ts
    apps/dashboard/src/lib/constants/infrastructure.ts
  </files>
  <action>
Create `apps/dashboard/src/lib/vmid-cache.ts` — a new module for caching taken VMIDs per Proxmox node in Redis.

**No "server-only"** — this module may be used by the worker process for cache invalidation on container create.

Add constants to `lib/constants/infrastructure.ts`:
```typescript
export const VMID_CACHE_PREFIX = "vmid-cache:";
export const VMID_CACHE_TTL_S = 300; // 5 minutes
```

**Module functions:**

1. `refreshVmidCache(nodeId: string, nodeName: string, client: ProxmoxClient): Promise<number[]>`
   - Call `containers.listContainers(client, nodeName)` to get all containers from Proxmox
   - Also call `containers.listContainers(client, nodeName)` with the qemu endpoint if applicable — actually, for LXC-only, just list LXC containers
   - Extract vmid from each container
   - Use Redis pipeline: `DEL key`, `SADD key ...vmids`, `EXPIRE key TTL`
   - Return the array of taken vmids
   - Import `listContainers` from `@/lib/proxmox/containers`

2. `isVmidTaken(nodeId: string, vmid: number): Promise<boolean>`
   - `SISMEMBER vmid-cache:{nodeId} {vmid}` — returns true if taken
   - If key doesn't exist (cache expired), return false (caller handles validation at create time via Proxmox API)

3. `invalidateVmidCache(nodeId: string): Promise<void>`
   - `DEL vmid-cache:{nodeId}`
   - Called after container create or delete to force cache refresh on next wizard open

4. `getCachedVmids(nodeId: string): Promise<number[]>`
   - `SMEMBERS vmid-cache:{nodeId}` — returns all cached vmids
   - Used by wizard to show inline validation

Import `getRedis` from `@/lib/redis`. Use the constants from `lib/constants/infrastructure.ts`.

Add JSDoc comments per codebase conventions.
  </action>
  <verify>
1. File exists at `apps/dashboard/src/lib/vmid-cache.ts`
2. All 4 functions are exported
3. No "server-only" import (worker needs this)
4. Constants added to `lib/constants/infrastructure.ts`
5. `npx tsc --noEmit` from apps/dashboard/ — vmid-cache.ts compiles (may have errors elsewhere, that's OK)
  </verify>
  <done>
VMID cache module exists with refreshVmidCache, isVmidTaken, invalidateVmidCache, and getCachedVmids functions. Uses Redis SET with 5-minute TTL per node.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create node management schemas and server actions</name>
  <files>
    apps/dashboard/src/lib/nodes/schemas.ts
    apps/dashboard/src/lib/nodes/actions.ts
  </files>
  <action>
Create the `lib/nodes/` directory with schemas and server actions for Proxmox node management.

**lib/nodes/schemas.ts** (no "use server", no "server-only" — shared with client forms):

```typescript
import { z } from "zod";

export const createNodeSchema = z.object({
  name: z.string().min(1, "Name is required").max(100, "Name too long"),
  host: z.string().min(1, "Host is required"),
  port: z.coerce.number().int().min(1).max(65535).default(8006),
  tokenId: z.string().min(1, "API Token ID is required (e.g., root@pam!mytoken)"),
  tokenSecret: z.string().min(1, "API Token Secret is required"),
  sshPassword: z.string().optional(), // Optional — needed for pct exec monitoring
});

export const updateNodeSchema = z.object({
  id: z.string().min(1),
  name: z.string().min(1, "Name is required").max(100, "Name too long"),
  host: z.string().min(1, "Host is required"),
  port: z.coerce.number().int().min(1).max(65535).default(8006),
  tokenId: z.string().min(1, "API Token ID is required"),
  tokenSecret: z.string().optional(), // Optional on update — keep existing if empty
  sshPassword: z.string().optional(),
});

export const deleteNodeSchema = z.object({
  id: z.string().min(1),
});

export const setDefaultNodeSchema = z.object({
  id: z.string().min(1),
});

export type CreateNodeInput = z.infer<typeof createNodeSchema>;
export type UpdateNodeInput = z.infer<typeof updateNodeSchema>;
```

**lib/nodes/actions.ts** ("use server"):

Import `authActionClient`, `ActionError` from safe-action. Import `DatabaseService` from db. Import `encrypt` from encryption. Import `ProxmoxClient` from proxmox/client. Import schemas from `./schemas`. Import `revalidatePath` from next/cache. Import `z` from zod.

1. **`createNodeAction`** — authActionClient.schema(createNodeSchema).action():
   - Extract `userId` from `ctx.userId`
   - Test connection: create a temporary `ProxmoxClient` with plaintext credentials, call `client.get("/version", z.object({}).passthrough())`. Wrap in try/catch — on failure, throw `ActionError("Could not connect to {host}:{port}. Verify credentials and host reachability.")`
   - Encrypt `tokenSecret` via `encrypt(data.tokenSecret)`
   - Encrypt `sshPassword` via `encrypt(data.sshPassword)` if provided
   - Check if user has any existing nodes: `DatabaseService.listNodesForUser(userId)`. If length === 0, this is the first node → set `isDefault: true`
   - Create node: `DatabaseService.createNode({ name, host, port, tokenId, tokenSecret: encrypted, sshPassword: encryptedSsh, isDefault, userId })`
   - `revalidatePath("/settings/nodes")`
   - Return `{ nodeId: node.id }`

2. **`updateNodeAction`** — authActionClient.schema(updateNodeSchema).action():
   - Verify ownership: `DatabaseService.getNodeById(data.id)` — if not found or `node.userId !== ctx.userId`, throw ActionError
   - Test connection with new credentials (only if tokenSecret provided — otherwise reuse existing encrypted value)
   - Build update data: encrypt new tokenSecret/sshPassword if provided, keep existing if not
   - `DatabaseService.updateNode(data.id, updateData)`
   - `revalidatePath("/settings/nodes")`
   - Return `{ success: true }`

3. **`deleteNodeAction`** — authActionClient.schema(deleteNodeSchema).action():
   - Verify ownership
   - Check if node has containers: `DatabaseService.getNodeById(data.id)` with container count (or query). If containers exist, throw ActionError("Cannot delete node with existing containers. Remove containers first.")
   - `DatabaseService.deleteNode(data.id)`
   - If deleted node was the default, promote the first remaining node to default (if any)
   - `revalidatePath("/settings/nodes")`
   - Return `{ success: true }`

4. **`setDefaultNodeAction`** — authActionClient.schema(setDefaultNodeSchema).action():
   - Verify ownership
   - `DatabaseService.setDefaultNode(ctx.userId, data.id)`
   - `revalidatePath("/settings/nodes")`
   - Return `{ success: true }`

5. **`testNodeConnectionAction`** — authActionClient.schema(z.object({ id: z.string() })).action():
   - Get node from DB, verify ownership
   - Create ProxmoxClient from node, call `/version`
   - Return `{ success: true, version: result.version }` or throw ActionError on failure
  </action>
  <verify>
1. `lib/nodes/schemas.ts` exists with createNodeSchema, updateNodeSchema, deleteNodeSchema
2. `lib/nodes/actions.ts` exists with "use server" directive
3. All 5 actions (create, update, delete, setDefault, testConnection) are exported
4. createNodeAction tests connection before saving
5. createNodeAction auto-sets isDefault for first node
6. `npx tsc --noEmit` from apps/dashboard/ — nodes/ files compile (other files may have errors)
  </verify>
  <done>
Node CRUD server actions with Zod validation, connection testing on create/update, auto-default for first node, ownership verification on all mutations. Schemas shared for client form validation.
  </done>
</task>

</tasks>

<verification>
1. vmid-cache.ts exports 4 functions using Redis SET
2. nodes/schemas.ts exports Zod schemas for all node operations
3. nodes/actions.ts exports 5 server actions with auth + connection testing
4. Constants for VMID cache added to infrastructure.ts
5. No env-var references in any new files
</verification>

<success_criteria>
- VMID cache module ready for wizard integration
- Node CRUD actions ready for settings page integration
- Connection testing validates Proxmox reachability before save
- First node auto-becomes default
- All new code follows established codebase patterns (authActionClient, DatabaseService, encrypt/decrypt)
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-infrastructure-refactor/03.5-03-SUMMARY.md`
</output>
