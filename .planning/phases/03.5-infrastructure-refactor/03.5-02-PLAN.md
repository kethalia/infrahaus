---
phase: 03.5-infrastructure-refactor
plan: 02
type: execute
wave: 2
depends_on: ["03.5-01"]
files_modified:
  - apps/dashboard/src/lib/safe-action.ts
  - apps/dashboard/src/lib/auth/actions.ts
  - apps/dashboard/src/middleware.ts
  - apps/dashboard/src/app/login/page.tsx
autonomous: true

must_haves:
  truths:
    - "authActionClient checks for a valid session and provides userId in context"
    - "Login action authenticates against Proxmox API and creates a session"
    - "Middleware redirects unauthenticated users to /login"
    - "No references to PVE_HOST or PVE_ROOT_PASSWORD in auth-related files"
    - "Login page presents host, port, username, password, and realm fields"
  artifacts:
    - path: "apps/dashboard/src/lib/safe-action.ts"
      provides: "Session-based auth middleware with userId in context"
      contains: "getSessionData"
    - path: "apps/dashboard/src/lib/auth/actions.ts"
      provides: "Real login/logout actions using Proxmox ticket auth"
      contains: "createSession"
    - path: "apps/dashboard/src/middleware.ts"
      provides: "Route protection that requires session"
      contains: "login"
    - path: "apps/dashboard/src/app/login/page.tsx"
      provides: "Login form UI with host, port, username, password, realm fields"
      contains: "loginAction"
  key_links:
    - from: "apps/dashboard/src/lib/safe-action.ts"
      to: "apps/dashboard/src/lib/session.ts"
      via: "getSessionData() call in middleware"
      pattern: "getSessionData"
    - from: "apps/dashboard/src/lib/auth/actions.ts"
      to: "apps/dashboard/src/lib/proxmox/auth"
      via: "login() call for Proxmox ticket"
      pattern: "login\\("
---

<objective>
Replace env-var-based authentication with real session-based auth. The authActionClient middleware checks for a valid session and provides userId to all server actions. Login action authenticates against Proxmox. Middleware protects routes.

Purpose: This is the auth foundation — every server action needs userId from context to scope node queries. Without this, no action can resolve which Proxmox node to use.
Output: Working session-based auth flow: login → session → userId in action context.
</objective>

<execution_context>
@/home/coder/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/coder/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03.5-infrastructure-refactor/03.5-RESEARCH.md
@apps/dashboard/src/lib/safe-action.ts
@apps/dashboard/src/lib/auth/actions.ts
@apps/dashboard/src/middleware.ts
@apps/dashboard/src/lib/session.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor authActionClient to session-based auth with userId context</name>
  <files>
    apps/dashboard/src/lib/safe-action.ts
  </files>
  <action>
Replace the current authActionClient middleware that checks `process.env.PVE_HOST` and `process.env.PVE_ROOT_PASSWORD` with a real session check.

**New implementation:**
```typescript
export const authActionClient = actionClient.use(async ({ next }) => {
  const sessionData = await getSessionData();
  if (!sessionData) {
    throw new Error("Authentication required. Please log in.");
  }
  // username from Proxmox session becomes the userId for node scoping
  // e.g., "root@pam" — unique per authenticated user
  return next({ ctx: { userId: sessionData.username } });
});
```

Import `getSessionData` from `@/lib/session`.

**Important:** This file already has `import "server-only"` which is correct. The `getSessionData()` function is server-only (uses cookies).

Remove ALL references to `process.env.PVE_HOST`, `process.env.PVE_ROOT_PASSWORD`, and `process.env.PVE_PORT` from this file.

Keep the `actionClient` (unauthenticated base) unchanged — it's still needed for login action.
Keep the `ActionError` class unchanged.
  </action>
  <verify>
Read the file and confirm:
1. No `process.env.PVE_` references
2. `getSessionData` is imported from session.ts
3. `ctx` includes `userId: sessionData.username`
4. `actionClient` (base) is still exported unchanged
  </verify>
  <done>
authActionClient checks for valid session via getSessionData(), provides userId (from session username) in ctx to all downstream actions. No env-var auth references remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Re-enable login/logout actions and update middleware for route protection</name>
  <files>
    apps/dashboard/src/lib/auth/actions.ts
    apps/dashboard/src/middleware.ts
    apps/dashboard/src/app/login/page.tsx
  </files>
  <action>
**lib/auth/actions.ts — Re-enable real login and logout:**

Replace the no-op login action with a real implementation:
1. Import `login` from `@/lib/proxmox/auth` (the existing Proxmox login function)
2. Import `createSession`, `destroySession` from `@/lib/session`
3. Import `redirect` from `next/navigation`
4. `loginAction` should:
   - Use `actionClient` (NOT authActionClient — user isn't authenticated yet)
   - Call `login(host, port, username, password, realm)` to get Proxmox ticket credentials
   - But wait — the host/port are no longer env vars. For login, the user authenticates against ANY Proxmox host they'll later add as a node. The simplest approach: login action just creates a session identity. The user provides username + password + realm. We validate against a Proxmox host by attempting login. But which host?
   
   **Resolution:** The login action needs a `host` field too, OR we simplify: since this is a home lab tool, login just establishes identity. The user provides their Proxmox username + password + host, we validate by calling the Proxmox login API, and store the session. The host used for login doesn't need to be persisted — it's just for validation. The user's actual node configurations are managed in Settings.
   
   Updated loginSchema:
   ```typescript
   const loginSchema = z.object({
     host: z.string().min(1, "Proxmox host is required"),
     port: z.coerce.number().int().min(1).max(65535).default(8006),
     username: z.string().min(1, "Username is required"),
     password: z.string().min(1, "Password is required"),
     realm: z.enum(["pam", "pve"]).default("pam"),
   });
   ```
   
   Login flow:
   1. Call Proxmox `login(host, port, username, password, realm)` — validates credentials
   2. If successful, call `createSession({ ticket, csrfToken, username: `${username}@${realm}`, realm, expiresAt })` from session.ts
   3. Return `{ success: true }`
   4. Catch errors → throw `ActionError("Invalid credentials or Proxmox host unreachable")`

5. `logoutAction` should:
   - Use `authActionClient` (requires session)
   - Call `destroySession()` from session.ts
   - Redirect to `/login`

**middleware.ts — Reverse the redirect and protect routes:**

Replace the current middleware that redirects `/login` to dashboard with route protection:

1. Allow `/login` and static assets without session check
2. For all other routes, check for session cookie presence
3. If no session cookie, redirect to `/login`

**Important:** Middleware runs in Edge Runtime — cannot use Redis or Node.js APIs. Can only check for cookie existence, not validate session contents. Full validation happens in authActionClient server-side.

```typescript
export function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Allow login page, API routes for login, and static assets
  if (
    pathname === "/login" ||
    pathname.startsWith("/login/") ||
    pathname.startsWith("/_next/") ||
    pathname.startsWith("/api/auth/")
  ) {
    return NextResponse.next();
  }

  // Check for session cookie (just existence, not validity)
  const sessionCookie = request.cookies.get("lxc-session");
  if (!sessionCookie) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  return NextResponse.next();
}
```

The cookie name must match `SESSION_COOKIE_NAME` from `lib/constants/infrastructure.ts` — the actual value is `"lxc-session"`. Hardcode the string in middleware since Edge Runtime can't import from those modules.

**app/login/page.tsx — Update login form to match new loginSchema:**

The existing login page has username/password fields only. Update it to present all fields required by the new loginSchema:

1. Add `host` field (Input, required) — label: "Proxmox Host", placeholder: "192.168.1.100 or pve.local"
2. Add `port` field (Input, type="number", default 8006) — label: "Port"
3. Keep `username` field (already exists)
4. Keep `password` field (already exists)
5. Add `realm` field (Select with options "pam" and "pve", default "pam") — label: "Realm"

Layout: host + port on the same row (host takes ~70% width, port ~30%). Username, password, realm below. Keep the existing form structure (react-hook-form + zodResolver). Update the form's Zod schema to match `loginSchema` from `@/lib/auth/actions.ts` (or import it directly). Wire the form submission to `loginAction` via `useAction()`.
  </action>
  <verify>
1. Read `lib/auth/actions.ts` — confirm loginAction calls Proxmox login API and creates session
2. Read `lib/auth/actions.ts` — confirm logoutAction calls destroySession and redirects to /login
3. Read `middleware.ts` — confirm unauthenticated requests redirect to /login
4. Read `middleware.ts` — confirm /login is accessible without session
5. No references to PVE_HOST or PVE_ROOT_PASSWORD in either file
6. Read `app/login/page.tsx` — confirm host, port, username, password, and realm fields are present
7. Login form schema matches loginSchema (host, port, username, password, realm)
  </verify>
  <done>
Login action authenticates against Proxmox and creates a Redis session with username. Logout action destroys session and redirects to /login. Middleware protects all routes except /login by checking for session cookie. Login page presents host, port, username, password, and realm fields matching the updated loginSchema.
  </done>
</task>

</tasks>

<verification>
1. safe-action.ts has session-based authActionClient with userId in ctx
2. auth/actions.ts has real login (Proxmox API + session creation) and logout (session destruction)
3. middleware.ts redirects unauthenticated users to /login
4. Zero references to PVE_HOST or PVE_ROOT_PASSWORD in any of these three files
5. The login page at /login should be accessible and functional (existing login UI from Phase 1)
</verification>

<success_criteria>
- authActionClient provides ctx.userId to all server actions
- Login action validates Proxmox credentials and creates session
- Logout action destroys session and redirects to /login
- Middleware protects all dashboard routes
- No env-var auth references in auth-related files
</success_criteria>

<output>
After completion, create `.planning/phases/03.5-infrastructure-refactor/03.5-02-SUMMARY.md`
</output>
