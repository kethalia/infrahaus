# Phase 3.5: Infrastructure Refactor - Research

**Researched:** 2026-02-20
**Domain:** Multi-user Proxmox credential management, Redis VMID caching, monitoring refactor
**Confidence:** HIGH

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Settings page for Proxmox nodes
- Dedicated `/settings/nodes` page — Proxmox node management only, no other app settings
- API token auth only (tokenId + tokenSecret) — no password-based auth. ProxmoxNode model already has these fields
- Test connection on save — hit Proxmox API with provided credentials before persisting, reject with error if unreachable
- Nodes are per-user — each authenticated user has their own set of nodes, no cross-user access
- Any authenticated user can access settings (no role system needed — home lab tool)

#### Multi-node behavior
- Default node + optional override in creation wizard — wizard uses default, shows "Change node" option
- First node added becomes the default automatically — no extra setup step for single-node users
- Graceful degradation when no nodes configured — templates and non-node features still work, container operations (create, lifecycle, monitoring) disabled with clear messaging
- Container dashboard shows all containers from all nodes, filterable by node — node badge on each container card

#### VMID picker in wizard
- Manual VMID entry only — empty field, user types a VMID
- Inline validation against cached taken IDs — red error if taken, green check if available. No visual map or range hints
- Proxmox default range accepted (100–999999999) — no artificial limits, don't be smarter than Proxmox
- On-demand cache refresh on wizard open + event-driven invalidation on container create/delete

#### Migration path
- Drop `rootPassword` column entirely — clean break, Prisma migration removes the column
- Hard cutover for `getProxmoxClient()` — rewrite to read from DB only, remove all PVE_HOST/PVE_PORT/PVE_ROOT_PASSWORD env var references
- Dashboard with prominent banner when no nodes configured — consistent with graceful degradation decision
- No migration helper — this is a new app with no existing users, manual setup in settings

### Claude's Discretion
- pct exec session implementation details (SSH to Proxmox host vs API approach)
- Redis VMID cache structure and TTL strategy
- Credential encryption approach for DB-stored tokens
- Settings page layout, form design, and component structure
- Node connection test timeout and error messaging
- Banner component design for unconfigured state

### Deferred Ideas (OUT OF SCOPE)
- Universal Profile (LUKSO) + RainbowKit + SIWE auth system — full replacement of current SSO auth with Web3 wallet-based authentication. Per-profile encrypted credential storage. This is a complete auth overhaul, not an infrastructure refactor — its own phase.
- Admin role / RBAC system — no need for home lab, revisit if multi-user access control becomes a requirement
- Settings page expansion (app config, user preferences, notifications) — add sections as future phases need them
</user_constraints>

## Summary

This phase refactors the dashboard's infrastructure layer from single-user env-var-based Proxmox authentication to multi-user DB-stored API token credentials, removes stored container passwords, adds a Redis VMID cache, and creates a settings page for node management. The work is primarily internal refactoring of existing patterns — no new major libraries are needed.

The codebase already has all the building blocks: `createProxmoxClientFromNode()` factory exists and correctly decrypts token credentials, `PctExecSession` is already implemented and used by the worker, AES-256-GCM encryption is in `lib/encryption.ts`, Redis patterns are established via `getRedis()`, and the `ProxmoxNode` model already has `tokenId`/`tokenSecret` fields. The refactoring needs to wire these existing pieces together, remove the env-var dependency path, and add a user-facing settings page.

Key areas requiring careful implementation: (1) adding `userId` to `ProxmoxNode` and `isDefault` flag for per-user scoping with a default node concept, (2) refactoring `getProxmoxClient()` and all 15+ call sites from env-var to DB-based auth, (3) building the VMID cache in Redis with invalidation on create/delete, (4) replacing the wizard's password field and `createContainer` DB operation to drop `rootPassword`, and (5) refactoring SSH connections in the worker and service logs route from env-var auth to DB-stored node credentials.

**Primary recommendation:** Work bottom-up — schema changes first, then data layer refactoring, then UI changes. Each refactored call site should use `createProxmoxClientFromNode()` which already works correctly.

## Standard Stack

The established libraries/tools for this domain — all already in use:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Prisma | 7.3.0 | Schema + migrations, `ProxmoxNode` model | Already in use, pg adapter |
| ioredis | 5.9.2 | VMID cache, sessions, Pub/Sub | Already in use via `getRedis()` |
| next-safe-action | 8.0.11 | Server actions for settings CRUD | Already in use for all auth'd actions |
| react-hook-form | 7.71.1 | Settings page forms | Already in use for wizard |
| zod | 4.3.6 | Schema validation | Already in use everywhere |
| shadcn/ui | latest | Settings page UI components | Required by CLAUDE.md conventions |
| ssh2 | 1.17.0 | SSH to Proxmox host for pct exec | Already in use |
| undici | 7.20.0 | HTTP client inside ProxmoxClient | Already in use |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| Node.js `crypto` | built-in | AES-256-GCM encryption | Already in `lib/encryption.ts` |
| lucide-react | 0.563.0 | Icons for settings page | Already in use app-wide |
| sonner | 2.0.7 | Toast notifications | Already in use for CRUD feedback |

### No New Libraries Needed

This phase requires zero new npm dependencies. Every capability needed already exists in the codebase.

## Architecture Patterns

### Affected Project Structure
```
src/
├── lib/
│   ├── proxmox/
│   │   └── index.ts          # REFACTOR: getProxmoxClient() → DB-based
│   ├── containers/
│   │   ├── actions.ts         # REFACTOR: remove env-var refs, add userId
│   │   ├── data.ts            # REFACTOR: multi-node client resolution
│   │   └── schemas.ts         # UPDATE: remove rootPassword, add VMID validation
│   ├── nodes/
│   │   ├── actions.ts         # NEW: settings CRUD server actions
│   │   └── schemas.ts         # NEW: node form validation schemas
│   ├── vmid-cache.ts          # NEW: Redis VMID cache module
│   ├── db.ts                  # UPDATE: add userId-scoped node queries
│   ├── safe-action.ts         # REFACTOR: real auth check (session required)
│   ├── session.ts             # May need userId accessor
│   └── encryption.ts          # REUSE: already handles AES-256-GCM
├── workers/
│   └── container-creation.ts  # REFACTOR: DB-based auth for SSH and Proxmox
├── app/
│   ├── (dashboard)/
│   │   ├── settings/
│   │   │   └── nodes/
│   │   │       └── page.tsx   # NEW: Proxmox node management
│   │   └── layout.tsx         # UPDATE: pass user identity
│   └── api/
│       └── containers/[id]/
│           └── services/logs/route.ts  # REFACTOR: DB-based SSH auth
└── components/
    └── app-sidebar.tsx        # Already has Settings nav link
```

### Pattern 1: DB-Based Proxmox Client Resolution
**What:** Replace env-var `getProxmoxClient()` with a function that takes a `nodeId` or resolves user's default node from DB, then calls `createProxmoxClientFromNode()`.
**When to use:** Every place that currently calls `getProxmoxClient()`.
**Example:**
```typescript
// NEW: lib/proxmox/index.ts
export async function getProxmoxClientForNode(nodeId: string): Promise<ProxmoxClient> {
  const node = await DatabaseService.getNodeById(nodeId);
  if (!node) throw new Error(`Node not found: ${nodeId}`);
  return createProxmoxClientFromNode(node);
}

// For actions that need the user's default node:
export async function getDefaultProxmoxClient(userId: string): Promise<{
  client: ProxmoxClient;
  node: ProxmoxNode;
}> {
  const node = await DatabaseService.getDefaultNodeForUser(userId);
  if (!node) throw new Error("No Proxmox node configured. Add one in Settings.");
  return { client: createProxmoxClientFromNode(node), node };
}
```

### Pattern 2: User-Scoped Node Queries
**What:** Add `userId` to `ProxmoxNode` model and scope all queries.
**When to use:** All node operations — list, create, get default.
**Example:**
```typescript
// DatabaseService additions
static async listNodesForUser(userId: string): Promise<ProxmoxNode[]> {
  return this.prisma.proxmoxNode.findMany({
    where: { userId },
    orderBy: { createdAt: 'asc' },
  });
}

static async getDefaultNodeForUser(userId: string): Promise<ProxmoxNode | null> {
  return this.prisma.proxmoxNode.findFirst({
    where: { userId, isDefault: true },
  });
}
```

### Pattern 3: Redis VMID Cache
**What:** Cache set of taken VMIDs per Proxmox node in Redis, validate in wizard.
**When to use:** Wizard open (populate cache), container create/delete (invalidate).
**Recommended structure:**
```typescript
// Key: vmid-cache:{nodeId}
// Value: Redis SET of taken VMID numbers
// TTL: 5 minutes (short — stale data means user picks taken VMID, caught at create time)

const VMID_CACHE_PREFIX = "vmid-cache:";
const VMID_CACHE_TTL_S = 300; // 5 minutes

export async function refreshVmidCache(nodeId: string, nodeName: string, client: ProxmoxClient): Promise<Set<number>> {
  const containers = await listContainers(client, nodeName);
  const vmids = containers.map(c => c.vmid);
  
  const redis = getRedis();
  const key = `${VMID_CACHE_PREFIX}${nodeId}`;
  
  // Use pipeline: delete old set, add all vmids, set TTL
  const pipeline = redis.pipeline();
  pipeline.del(key);
  if (vmids.length > 0) {
    pipeline.sadd(key, ...vmids.map(String));
  }
  pipeline.expire(key, VMID_CACHE_TTL_S);
  await pipeline.exec();
  
  return new Set(vmids);
}

export async function isVmidTaken(nodeId: string, vmid: number): Promise<boolean> {
  const redis = getRedis();
  return (await redis.sismember(`${VMID_CACHE_PREFIX}${nodeId}`, String(vmid))) === 1;
}

export async function invalidateVmidCache(nodeId: string): Promise<void> {
  const redis = getRedis();
  await redis.del(`${VMID_CACHE_PREFIX}${nodeId}`);
}
```

### Pattern 4: SSH via DB-Stored Node Credentials for pct exec
**What:** Instead of using `PVE_HOST`/`PVE_ROOT_PASSWORD` env vars for SSH, SSH into the Proxmox host using API token or a stored SSH key/password from the node record.
**Critical issue:** API tokens authenticate HTTP requests, not SSH. SSH to the Proxmox host still requires either:
  1. An SSH key (user provides when adding node)
  2. Root password for the Proxmox host (separate from API token)
  
**Recommendation:** Add optional `sshUser` and `sshKeyOrPassword` (encrypted) fields to `ProxmoxNode` model. When present, use them for pct exec connections. For API calls, use tokenId/tokenSecret. This keeps SSH auth separate from API auth, which is how Proxmox works in practice.

**Alternative (simpler):** Use `pct exec` via the Proxmox API's `POST /nodes/{node}/lxc/{vmid}/vncproxy` or execute commands through the API. However, Proxmox's REST API does not have a direct "exec command" endpoint for LXC containers. The `pct exec` command is only available on the host CLI via SSH.

**Decision:** Continue SSH approach (already works) but source credentials from DB instead of env vars. Add `sshPassword` field (encrypted) to `ProxmoxNode`. This is the simplest path since `PctExecSession` already works perfectly via SSH.

### Pattern 5: Settings Page Form Pattern
**What:** Follow established form conventions from CLAUDE.md.
**Structure:**
```typescript
// lib/nodes/schemas.ts — shared Zod schemas
export const createNodeSchema = z.object({
  name: z.string().min(1, "Name is required").max(100),
  host: z.string().min(1, "Host is required"),
  port: z.number().int().min(1).max(65535).default(8006),
  tokenId: z.string().min(1, "Token ID is required"),
  tokenSecret: z.string().min(1, "Token secret is required"),
  isDefault: z.boolean().default(false),
});

// lib/nodes/actions.ts — server actions
export const createNodeAction = authActionClient
  .schema(createNodeSchema)
  .action(async ({ parsedInput: data, ctx }) => {
    // Test connection first
    const testClient = new ProxmoxClient({
      host: data.host,
      port: data.port,
      credentials: { type: "token", tokenId: data.tokenId, tokenSecret: data.tokenSecret },
      verifySsl: false,
    });
    
    // Verify connection by listing nodes
    await testClient.get("/nodes", z.array(z.object({}).passthrough()));
    
    // Encrypt token secret before storing
    const encrypted = encrypt(data.tokenSecret);
    
    // Create node...
  });
```

### Pattern 6: Graceful Degradation Banner
**What:** Prominent alert when no nodes configured, disabling container operations.
**When:** Dashboard page, wizard page — any page that requires a Proxmox connection.
```typescript
// Reusable component pattern
<Alert variant="default" className="border-amber-500 bg-amber-50 dark:bg-amber-950/20">
  <AlertTriangle className="h-4 w-4 text-amber-500" />
  <AlertTitle>No Proxmox nodes configured</AlertTitle>
  <AlertDescription>
    Add a Proxmox node in <Link href="/settings/nodes">Settings</Link> to manage containers.
  </AlertDescription>
</Alert>
```

### Anti-Patterns to Avoid
- **Don't keep env-var fallback:** The decision is hard cutover. Don't add `if (envVars) useEnv() else useDB()` branching — it creates two code paths to maintain.
- **Don't cache Proxmox clients per-node in module scope:** Clients are cheap to create with token auth (no login step). Create fresh per-request.
- **Don't add userId to Container model:** Containers are linked to nodes, nodes are linked to users. The user→container path goes through the node relationship.
- **Don't use Proxmox API for command execution:** There is no REST endpoint for `pct exec`. SSH to the host is the only way.
- **Don't encrypt tokenId:** Only the `tokenSecret` needs encryption. `tokenId` is like a username (e.g., `root@pam!mytoken`), not sensitive.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Credential encryption | Custom encryption | `lib/encryption.ts` (AES-256-GCM) | Already handles iv, authTag, base64 encoding |
| Form validation | Custom validators | zod + zodResolver + shadcn Form | Established pattern in codebase |
| Toast notifications | Custom notification system | sonner (already installed) | Convention from CLAUDE.md |
| Node connection testing | Custom HTTP client | `ProxmoxClient` constructor + `client.get("/nodes")` | Already handles SSL, timeouts, retries |
| SSH to Proxmox host | New SSH helper | `connectWithRetry()` + `PctExecSession` | Already implemented in `lib/ssh.ts` |
| VMID uniqueness check | DB-based unique constraint | Redis SET with `SISMEMBER` | O(1) lookup, event-driven invalidation |
| Node CRUD server actions | Raw fetch calls | `authActionClient.schema().action()` | Established next-safe-action pattern |

**Key insight:** This entire phase is rewiring existing building blocks. The main risk is forgetting a call site when migrating from env-vars to DB-based auth.

## Common Pitfalls

### Pitfall 1: Missing env-var references after migration
**What goes wrong:** After removing `PVE_HOST`/`PVE_ROOT_PASSWORD` support, some code path still references them at runtime, causing crash.
**Why it happens:** There are 15+ references across 6 files (proxmox/index.ts, containers/actions.ts, containers/data.ts, safe-action.ts, workers/container-creation.ts, api/containers/[id]/services/logs/route.ts, middleware.ts).
**How to avoid:** Grep for `PVE_HOST`, `PVE_ROOT_PASSWORD`, `PVE_PORT`, `PVE_NODE` across entire codebase after migration. Every reference should be removed or replaced.
**Warning signs:** Build succeeds but runtime error when attempting container operations.

### Pitfall 2: Worker process doesn't have request context
**What goes wrong:** Worker runs as standalone `tsx` process, has no Next.js request context and no session/cookies.
**Why it happens:** `authActionClient` middleware checks session — but the worker doesn't go through actions, it processes BullMQ jobs directly.
**How to avoid:** The worker receives `nodeId` in the job data (already does). It should use `DatabaseService.getNodeById(nodeId)` + `createProxmoxClientFromNode()` directly. No session needed. The SSH credentials should also be resolved from the node record, not env vars.
**Warning signs:** Worker throws "session not found" or "userId required" errors.

### Pitfall 3: SSH auth separate from API token auth
**What goes wrong:** API tokens authenticate HTTP API requests. They don't work for SSH login to the Proxmox host.
**Why it happens:** The current code SSHs into the Proxmox host using `PVE_ROOT_PASSWORD` (root SSH password). API tokens are a different auth mechanism.
**How to avoid:** Add an `sshPassword` (encrypted) field to `ProxmoxNode`. When the user adds a node, they provide both the API token (for Proxmox REST API) and SSH password (for pct exec access). The form should clearly label these as separate credentials.
**Warning signs:** Connection works for API calls but SSH to the Proxmox host fails after removing env vars.

### Pitfall 4: Default node race condition on first node creation
**What goes wrong:** First node should automatically become the default. If concurrent requests create two nodes, both might try to become default.
**Why it happens:** Check-then-set without locking.
**How to avoid:** Use Prisma transaction: check if user has any nodes, if not set `isDefault: true`. Or use a unique partial index on `(userId, isDefault) WHERE isDefault = true` to enforce only one default per user.
**Warning signs:** User has two default nodes, or no default node after adding first node.

### Pitfall 5: Wizard requires nodeId before it exists
**What goes wrong:** Wizard fetches Proxmox data (storages, bridges, OS templates, next VMID) but needs a Proxmox client which now requires a node from DB.
**Why it happens:** `getWizardData()` currently calls `getProxmoxClient()` which uses env vars.
**How to avoid:** `getWizardData()` should accept a `nodeId` parameter (or resolve the user's default node). If no node configured, return early with `noNodeConfigured: true` (already handled).
**Warning signs:** Wizard page crashes on load because no default node exists.

### Pitfall 6: ProxmoxNode `name` unique constraint conflicts with per-user nodes
**What goes wrong:** Current schema has `name String @unique` on ProxmoxNode. If two users both name their node "pve", the second one fails.
**Why it happens:** Global unique constraint doesn't account for per-user scoping.
**How to avoid:** Change to `@@unique([userId, name])` compound unique index. Each user can have unique names within their own set.
**Warning signs:** "Unique constraint violation on name" when second user adds a node with the same name as another user's node.

### Pitfall 7: Container model FK to ProxmoxNode during migration
**What goes wrong:** Existing containers reference ProxmoxNode records that were created with placeholder data (see `getOrCreateNode()` in actions.ts).
**Why it happens:** Current code auto-creates node records with fake token data (`encrypt("env-auth-no-token")`).
**How to avoid:** Decision says "no existing users" — clean break. Migration should be safe to drop and recreate. But verify: if there's test data in the DB, the foreign key from Container→ProxmoxNode will break if nodes are deleted.
**Warning signs:** Migration fails due to foreign key constraints.

### Pitfall 8: Forgetting to pass nodeId to worker job
**What goes wrong:** Worker job needs nodeId to resolve SSH credentials from DB. If not passed, worker can't connect.
**Why it happens:** Currently the worker uses env vars, so it doesn't need nodeId for SSH — only for Proxmox API calls.
**How to avoid:** The `ContainerJobData` type already has `nodeId`. Ensure the job data also carries enough info for the worker to SSH into the Proxmox host (nodeId is sufficient — worker resolves SSH credentials from DB).
**Warning signs:** Worker creates container via API successfully but fails at the SSH/pct exec phase.

## Code Examples

### Example 1: Refactored getProxmoxClient for DB-based auth
```typescript
// lib/proxmox/index.ts — AFTER refactor
import type { ProxmoxNode } from "@/generated/prisma/client";
import { decrypt } from "../encryption";
import { ProxmoxClient } from "./client";
import type { ProxmoxApiTokenCredentials, ProxmoxClientConfig } from "./types";

/**
 * Create a Proxmox client from a node's DB record.
 * This is now the ONLY way to get a Proxmox client.
 * (Already exists as createProxmoxClientFromNode)
 */
export function createProxmoxClientFromNode(
  node: ProxmoxNode,
  verifySsl = false,
): ProxmoxClient {
  const tokenSecret = decrypt(node.tokenSecret);
  const credentials: ProxmoxApiTokenCredentials = {
    type: "token",
    tokenId: node.tokenId,
    tokenSecret,
  };
  return new ProxmoxClient({ host: node.host, port: node.port, credentials, verifySsl });
}

// REMOVED: getProxmoxClient() — no more env-var based auth
// REMOVED: createProxmoxClientFromTicket() — deprecated
```

### Example 2: Node creation action with connection test
```typescript
// lib/nodes/actions.ts
"use server";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import { authActionClient, ActionError } from "@/lib/safe-action";
import { DatabaseService } from "@/lib/db";
import { encrypt } from "@/lib/encryption";
import { ProxmoxClient } from "@/lib/proxmox/client";
import { createNodeSchema } from "./schemas";

export const createNodeAction = authActionClient
  .schema(createNodeSchema)
  .action(async ({ parsedInput: data, ctx }) => {
    const userId = ctx.userId; // from auth middleware
    
    // 1. Test connection
    const testClient = new ProxmoxClient({
      host: data.host,
      port: data.port,
      credentials: {
        type: "token",
        tokenId: data.tokenId,
        tokenSecret: data.tokenSecret, // plaintext for test
      },
      verifySsl: false,
    });
    
    try {
      await testClient.get("/version", z.object({}).passthrough());
    } catch (err) {
      throw new ActionError(
        `Could not connect to ${data.host}:${data.port}. Check your credentials and ensure the Proxmox host is reachable.`
      );
    }
    
    // 2. Encrypt and store
    const encryptedSecret = encrypt(data.tokenSecret);
    
    // 3. Determine if this is the first node (auto-default)
    const existingNodes = await DatabaseService.listNodesForUser(userId);
    const isDefault = existingNodes.length === 0;
    
    const node = await DatabaseService.createNode({
      name: data.name,
      host: data.host,
      port: data.port,
      tokenId: data.tokenId,
      tokenSecret: encryptedSecret,
      isDefault,
      userId,
    });
    
    revalidatePath("/settings/nodes");
    return { nodeId: node.id };
  });
```

### Example 3: Redis VMID cache operations
```typescript
// lib/vmid-cache.ts
import { getRedis } from "@/lib/redis";
import { listContainers } from "@/lib/proxmox/containers";
import type { ProxmoxClient } from "@/lib/proxmox/client";

const VMID_CACHE_PREFIX = "vmid-cache:";
const VMID_CACHE_TTL_S = 300; // 5 minutes

/** Refresh the VMID cache for a node by querying Proxmox */
export async function refreshVmidCache(
  nodeId: string,
  nodeName: string,
  client: ProxmoxClient,
): Promise<number[]> {
  const containers = await listContainers(client, nodeName);
  const vmids = containers.map((c) => c.vmid);

  const redis = getRedis();
  const key = `${VMID_CACHE_PREFIX}${nodeId}`;

  const pipeline = redis.pipeline();
  pipeline.del(key);
  if (vmids.length > 0) {
    pipeline.sadd(key, ...vmids.map(String));
  }
  pipeline.expire(key, VMID_CACHE_TTL_S);
  await pipeline.exec();

  return vmids;
}

/** Check if a VMID is taken (from cache) */
export async function isVmidTaken(nodeId: string, vmid: number): Promise<boolean> {
  const redis = getRedis();
  return (await redis.sismember(`${VMID_CACHE_PREFIX}${nodeId}`, String(vmid))) === 1;
}

/** Invalidate cache after create/delete */
export async function invalidateVmidCache(nodeId: string): Promise<void> {
  const redis = getRedis();
  await redis.del(`${VMID_CACHE_PREFIX}${nodeId}`);
}
```

### Example 4: Prisma schema changes
```prisma
model ProxmoxNode {
  id           String   @id @default(cuid())
  name         String
  host         String
  port         Int      @default(8006)
  tokenId      String
  tokenSecret  String   // Encrypted via encryption utility
  sshPassword  String?  // Encrypted — for pct exec SSH access
  fingerprint  String?
  isDefault    Boolean  @default(false)
  userId       String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  containers Container[]

  @@unique([userId, name])
  // Enforce at most one default per user (PostgreSQL partial unique index)
  // Note: Prisma doesn't natively support partial indexes. Use @@index
  // and enforce in application logic, or add via raw SQL migration.
}

model Container {
  id        String             @id @default(cuid())
  vmid      Int                @unique
  hostname  String?
  lifecycle ContainerLifecycle @default(creating)
  // rootPassword REMOVED — no longer stored
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  nodeId     String
  node       ProxmoxNode @relation(fields: [nodeId], references: [id])
  templateId String?
  template   Template?   @relation(fields: [templateId], references: [id])

  events ContainerEvent[]

  @@index([lifecycle])
  @@index([nodeId])
  @@index([templateId])
}
```

### Example 5: Refactored authActionClient with real auth
```typescript
// lib/safe-action.ts
export const authActionClient = actionClient.use(async ({ next }) => {
  const sessionData = await getSessionData();
  if (!sessionData) {
    throw new Error("Authentication required. Please log in.");
  }

  return next({ ctx: { userId: sessionData.username } });
});
```

**Note:** The userId comes from the session. Current auth stores `username` (e.g., "root@pam") in Redis session data. This becomes the userId for node scoping. When the future Web3 auth phase replaces sessions, the userId source changes but the pattern stays the same.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Env-var auth (`PVE_HOST`+`PVE_ROOT_PASSWORD`) | DB-stored API tokens per user | This phase | Enables multi-user, removes deployment env coupling |
| `getProxmoxClient()` global factory | `createProxmoxClientFromNode(node)` per-request | This phase | Already exists — just promoting to primary path |
| Root password stored in Container model | No password storage | This phase | Clean break, `pct exec` doesn't need container passwords |
| Proxmox `/cluster/nextid` for VMID | Redis VMID cache with inline validation | This phase | Faster validation, prevents stale VMID suggestions |
| Direct SSH into containers (SSHSession) | `PctExecSession` via Proxmox host SSH | Phase 3 (existing) | Already done — worker already uses `PctExecSession` |

**Already completed migrations:**
- `PctExecSession` is already the primary execution method in the worker (not `SSHSession` directly into containers)
- `createProxmoxClientFromNode()` already exists and works
- AES-256-GCM encryption already handles token storage

## Inventory of Call Sites Requiring Migration

### `getProxmoxClient()` — 6 call sites to refactor
1. `lib/containers/actions.ts` line 152 — `getOrCreateNode()` helper
2. `lib/containers/actions.ts` line 204 — `getWizardData()`
3. `lib/containers/actions.ts` line 453 — `createContainerAction` VMID conflict check
4. `lib/containers/actions.ts` line 584 — `getContainerContext()` helper
5. `lib/containers/actions.ts` line 881 — `refreshContainerServicesAction`
6. `lib/containers/data.ts` line 153 — `getContainersWithStatus()`
7. `lib/containers/data.ts` line 274 — `getContainerDetailData()`
8. `workers/container-creation.ts` line 231 — Worker Phase 1

### `PVE_HOST`/`PVE_ROOT_PASSWORD` for SSH — 4 call sites
1. `workers/container-creation.ts` lines 317-328 — Worker SSH connection
2. `lib/containers/actions.ts` lines 900-905 — `refreshContainerServicesAction`
3. `api/containers/[id]/services/logs/route.ts` lines 57-62 — Service log fetching
4. `lib/safe-action.ts` lines 54-56 — Auth middleware check

### `rootPassword` in Container model — 4 references
1. `prisma/schema.prisma` line 145 — Column definition
2. `lib/db.ts` line 612 — `createContainer()` method signature
3. `lib/containers/actions.ts` line 424 — `encrypt(data.rootPassword)`
4. `lib/containers/schemas.ts` — `rootPassword` field in schema (also `confirmPassword`)

### `process.env.PVE_NODE` — 1 reference
1. `lib/containers/actions.ts` line 217 — Node filtering in `getWizardData()`

## Auth Model Clarification

The current session system (iron-session + Redis) stores Proxmox ticket credentials. After this refactor:

1. **Session still needed:** The session identifies the user (via `username` field like `root@pam`). This becomes the `userId` for node scoping.
2. **Session no longer stores Proxmox credentials:** Proxmox auth comes from DB-stored API tokens on `ProxmoxNode`, not from session tickets.
3. **Auth middleware changes:** `authActionClient` checks for a valid session (user is logged in), not for env vars.
4. **Worker auth:** Worker doesn't use sessions. It receives `nodeId` in job data and resolves credentials from DB directly.
5. **Login flow:** User logs in → session created with `username` → username becomes userId for all DB queries → Proxmox operations use the user's configured nodes from DB.

**Important:** The current login action is a no-op (env-var auth). This phase needs to re-enable real login or at minimum require a session. Given the deferred Web3 auth, the simplest approach is: keep the existing Proxmox ticket-based login flow but also wire up node management. Users log in with Proxmox credentials, which gives them a session identity, and their DB-stored API tokens handle actual API calls.

## Open Questions

1. **SSH credentials storage model**
   - What we know: API tokens work for REST API. SSH needs separate auth (password or key).
   - What's unclear: Should we add `sshPassword` to ProxmoxNode, or should users set up SSH key auth independently?
   - Recommendation: Add `sshPassword` (encrypted) field to ProxmoxNode. This is the simplest path and mirrors the current env-var approach. Document that users can also set up SSH key auth on the host.

2. **Multi-node VMID cache scope**
   - What we know: VMIDs must be unique per Proxmox cluster, not per node.
   - What's unclear: If a user has nodes in the same cluster, should VMID cache be per-cluster or per-node?
   - Recommendation: Cache per-node (simpler). When creating a container, validate against the target node's cache. If user picks a VMID that's taken on another node in the same cluster, the Proxmox API will reject it — acceptable UX for home lab.

3. **User identity during migration**
   - What we know: Current login is a no-op stub. Session stores Proxmox ticket data. Decision says "no existing users."
   - What's unclear: What's the minimal login flow needed?
   - Recommendation: Re-enable the existing Proxmox ticket login (was disabled in middleware). User logs in with Proxmox credentials → session established → session username = userId. This gives us per-user node scoping without building a new auth system (deferred to Web3 phase).

## Sources

### Primary (HIGH confidence)
- Codebase analysis: All files in `apps/dashboard/src/` examined directly
- Prisma schema: `apps/dashboard/prisma/schema.prisma` — current model definitions
- Existing implementations: `createProxmoxClientFromNode()`, `PctExecSession`, `encrypt()`/`decrypt()`, Redis patterns

### Secondary (MEDIUM confidence)
- Proxmox VE API documentation (re: API token auth format `PVEAPIToken=user@realm!tokenname=secret`)
- Proxmox VE docs (re: no REST endpoint for `pct exec` — CLI only)

### Tertiary (LOW confidence)
- PostgreSQL partial unique index support in Prisma — may need raw SQL migration for `@@unique where isDefault = true` pattern

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — zero new libraries, all patterns exist in codebase
- Architecture: HIGH — existing building blocks, well-understood refactoring
- Pitfalls: HIGH — identified from direct codebase analysis of all affected files
- SSH auth model: MEDIUM — needs validation that sshPassword field is the right approach
- Auth flow re-enablement: MEDIUM — depends on how much of current session system to reuse

**Research date:** 2026-02-20
**Valid until:** 2026-03-20 (stable — internal refactoring of established patterns)
